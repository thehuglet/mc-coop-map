from bolt_expressions import Scoreboard, Data
from copy import copy
from src.definitions import
    LOAD,
    TICK,
    PLAYER_TICK,
    GameState,
    VAR_OBJECTIVE,
    TMP_OBJECTIVE,
    STORAGE,
    BASE_ENEMY_NBT,
    ItemSpec,
    Enemy,
from src.wave_definition import parse_wave, WAVE_0

from ./reload import tick_reload_watcher
from ./loot_tables import generate_loot_tables
from ./helpers import predictable_arrow_rotation, inventory_item_count, randint_range, get_gametime, get_xp_levels
from ./spec_itemstacks import
    BOW_ITEMSTACK_DEFINITIONS,
    SWORD_ITEMSTACK_DEFINITIONS,
from ./upgrade_book_contents import
    EntryData,
    UPGRADE_BOOK_BOW_CONTENTS,
    UPGRADE_BOOK_SWORD_CONTENTS,
import ./weapon/blasthra as weapon_blasthra
import ./weapon/plague_volley as weapon_plague_volley
import ./weapon/iron_tempest as weapon_iron_tempest
import math

this = Data.entity("@s")
storage = Data.storage(STORAGE)
vars = Scoreboard(VAR_OBJECTIVE, "dummy")
tmp = Scoreboard(TMP_OBJECTIVE, "dummy")

upgrade_book_buy_trigger = Scoreboard("coop.upgrade_book.buy_trigger", "trigger")
enemy_aggro_timer = Scoreboard("coop.enemy_aggro_timer", "dummy")
current_sword_spec = Scoreboard("coop.current_spec.sword", "dummy")
current_sword_level = Scoreboard("coop.current_level.sword", "dummy")
current_bow_spec = Scoreboard("coop.current_spec.bow", "dummy")
current_bow_level = Scoreboard("coop.current_level.bow", "dummy")


merge function_tag minecraft:load {"values": [LOAD]}
merge function_tag minecraft:tick {"values": [TICK]}

generate_loot_tables()
weapon_blasthra.generate_funcs()
weapon_plague_volley.generate_funcs()
weapon_iron_tempest.generate_funcs()

def encode_trigger_value(spec: int, level: int) -> int:
    return spec * 1000 + level

def update_upgrade_menu_item(modify_existing_mainhand: bool):
    def generate_header_modifier(text: str) -> dict:
        return {
            "function": "minecraft:set_written_book_pages",
            "pages": [{
                "text": f"{text}\n",
                "extra": [{
                    "text": "-------------\n",
                    "color": "#9a9996",
                }],
                "color": "black",
            }],
            "mode": "replace_all"
        }

    def get_book_entry(entry_data: EntryData) -> dict:
        return {
            "text": str(entry_data.lvl),
            "color": "dark_green",
            "extra": [
                " ",
                {
                    "text": f"{entry_data.name} ({entry_data.price})",
                    "color": "#5e5c64",
                },
                br
            ],
            "click_event": {
                "action": "run_command",
                "command": f"trigger {upgrade_book_buy_trigger} set {encoded_upgrade_value}",
            }
        }

    execute function coop:update_upgrade_menu_item:
        ysb_items = Data.block("0 0 0").Items
        main_item_data_text_list = ysb_items[0].components["minecraft:written_book_content"].pages[0].raw.extra
        aux_item_data_text = ysb_items[1].components["minecraft:written_book_content"].pages[0].raw
        
        br = "\n"
        blank_slate_modifier = '{function:"minecraft:set_written_book_pages",pages:[{raw:{text:"",extra:[""]}}],mode:"replace_all"}'

        # Initialization    
        ysb_items.remove()
        item replace block 0 0 0 container.0 with written_book[custom_data={upgrade_book: True}]
        item modify block 0 0 0 container.0 blank_slate_modifier

        # Those for loops are completely cursed
        # they're optimized for compile time by keeping commands inline
        # instead of spamming nested executes
        item replace block 0 0 0 container.1 with written_book
        item modify block 0 0 0 container.1 generate_header_modifier("Sword Upgrades")
        main_item_data_text_list.append(aux_item_data_text)

        for entry_data in UPGRADE_BOOK_SWORD_CONTENTS:
            item replace block 0 0 0 container.1 with written_book
            execute if score @s current_sword_level matches entry_data.req_lvl if score @s current_sword_spec matches entry_data.req_spec.value:
                encoded_upgrade_value = encode_trigger_value(entry_data.spec.value, entry_data.lvl)
                modifier = {
                    "function": "minecraft:set_written_book_pages",
                    "pages": [get_book_entry(entry_data)],
                    "mode": "replace_all"
                }
                item modify block 0 0 0 container.1 modifier
            main_item_data_text_list.append(aux_item_data_text)
        
        item replace block 0 0 0 container.1 with written_book
        item modify block 0 0 0 container.1 generate_header_modifier("\nBow Upgrades")
        main_item_data_text_list.append(aux_item_data_text)

        for entry_data in UPGRADE_BOOK_BOW_CONTENTS:
            item replace block 0 0 0 container.1 with written_book
            execute if score @s current_bow_level matches entry_data.req_lvl if score @s current_bow_spec matches entry_data.req_spec.value:
                encoded_upgrade_value = encode_trigger_value(entry_data.spec.value, entry_data.lvl)
                modifier = {
                    "function": "minecraft:set_written_book_pages",
                    "pages": [get_book_entry(entry_data)],
                    "mode": "replace_all"
                }
                item modify block 0 0 0 container.1 modifier
            main_item_data_text_list.append(aux_item_data_text)

        # get rid of auxillary item before moving
        # stuff to the player's inventory
        ysb_items[1].remove()

    if modify_existing_mainhand:
        loot replace entity @s weapon.mainhand mine 0 0 0 stick[custom_data={drop_contents:1b}]
    else:
        clear @s written_book[minecraft:custom_data~{upgrade_book: 1b}]
        loot give @s mine 0 0 0 stick[custom_data={drop_contents:1b}]

function ./summon/basic_zombie:
    summon zombie ~ ~ ~ {DeathLootTable:"coop:coin_1",PersistenceRequired:1b,CanPickUpLoot:0b,CanBreakDoors:0b,Tags:["coop.enemy", "coop.spawn_temp"],equipment:{head:{id:"minecraft:oak_button",count:1}},drop_chances:{head:0.000},attributes:[{id:"minecraft:follow_range",base:2048},{id:"minecraft:spawn_reinforcements",base:0}]}

function ./summon/conehead_zombie:
    summon zombie ~ ~ ~ {DeathLootTable:"coop:coin_2",PersistenceRequired:1b,CanPickUpLoot:0b,Health:40f,CanBreakDoors:0b,Tags:["coop.enemy", "coop.spawn_temp"],equipment:{head:{id:"minecraft:oak_button",count:1,components:{"minecraft:item_model":"coop:conehead"}}},drop_chances:{head:0.000},attributes:[{id:"minecraft:follow_range",base:2048},{id:"minecraft:max_health",base:40},{id:"minecraft:spawn_reinforcements",base:0}]}

function ./summon/buckethead_zombie:
    summon zombie ~ ~ ~ {DeathLootTable:"coop:coin_3",PersistenceRequired:1b,CanPickUpLoot:0b,Health:60f,CanBreakDoors:0b,Tags:["coop.enemy", "coop.spawn_temp"],equipment:{head:{id:"minecraft:oak_button",count:1,components:{"minecraft:item_model":"coop:buckethead"}}},drop_chances:{head:0.000},attributes:[{id:"minecraft:follow_range",base:2048},{id:"minecraft:max_health",base:60},{id:"minecraft:spawn_reinforcements",base:0}]}

function ./summon/imp:
    summon zombie ~ ~ ~ {DeathLootTable:"coop:coin_1",PersistenceRequired:1b,CanPickUpLoot:0b,Health:10f,IsBaby:1b,CanBreakDoors:0b,Tags:["coop.enemy","oop.spawn_temp"],equipment:{head:{id:"minecraft:oak_button",count:1}},drop_chances:{head:0.000},attributes:[{id:"minecraft:follow_range",base:2048},{id:"minecraft:max_health",base:10},{id:"minecraft:movement_speed",base:0.18},{id:"minecraft:spawn_reinforcements",base:0}]}

function ./summon/shield_zombie:
    summon zombie_villager ~ ~ ~ {DeathLootTable:"coop:coin_3",PersistenceRequired:1b,CanPickUpLoot:0b,Health:40f,Tags:["coop.enemy","coop.spawn_temp"],equipment:{head:{id:"minecraft:lectern",count:1},mainhand:{id:"minecraft:shield",count:1},offhand:{id:"minecraft:shield",count:1}},drop_chances:{head:0.000,mainhand:0.000,offhand:0.000},attributes:[{id:"minecraft:follow_range",base:2048},{id:"minecraft:max_health",base:40}],VillagerData:{type:"minecraft:plains"}}

function ./summon/color_imp_trio:
    summon zombie ~ ~ ~ {DeathLootTable:"coop:coin_1",PersistenceRequired:1b,CanPickUpLoot:0b,Health:10f,IsBaby:1b,CanBreakDoors:0b,Tags:["coop.enemy","oop.spawn_temp"],Passengers:[{id:"minecraft:zombie",DeathLootTable:"coop:coin_1",PersistenceRequired:1b,CanPickUpLoot:0b,Health:10f,IsBaby:1b,CanBreakDoors:0b,Tags:["coop.enemy","oop.spawn_temp"],Passengers:[{id:"minecraft:zombie",DeathLootTable:"coop:coin_1",PersistenceRequired:1b,CanPickUpLoot:0b,Health:10f,IsBaby:1b,CanBreakDoors:0b,Tags:["coop.enemy","oop.spawn_temp"],equipment:{head:{id:"minecraft:red_glazed_terracotta",count:1}},drop_chances:{head:0.000},attributes:[{id:"minecraft:follow_range",base:2048},{id:"minecraft:max_health",base:10},{id:"minecraft:movement_speed",base:0.26},{id:"minecraft:spawn_reinforcements",base:0}]}],equipment:{head:{id:"minecraft:yellow_glazed_terracotta",count:1,components:{"minecraft:dyed_color":16252672}}},attributes:[{id:"minecraft:follow_range",base:2048},{id:"minecraft:max_health",base:10},{id:"minecraft:movement_speed",base:0.22},{id:"minecraft:spawn_reinforcements",base:0}]}],equipment:{head:{id:"minecraft:lime_glazed_terracotta",count:1,components:{"minecraft:dyed_color":3407616}}},drop_chances:{head:0.000},attributes:[{id:"minecraft:follow_range",base:2048},{id:"minecraft:max_health",base:10},{id:"minecraft:movement_speed",base:0.18},{id:"minecraft:spawn_reinforcements",base:0}]}

function coop:start_game:
    vars[".game_state"] = GameState.RUNNING.value
    say Game started!

    current_sword_spec["@a"] = ItemSpec.SWORD_NONE.value
    current_sword_level["@a"] = 0
    current_bow_spec["@a"] = ItemSpec.BOW_NONE.value
    current_bow_level["@a"] = 0
    # clear @s written_book[minecraft:custom_data~{upgrade_book: 1b}]
    # clear @a
    storage.current_wave = parse_wave(WAVE_0)
    vars[".enemy_spawn_timer"] = 0
    item replace entity @a inventory.0 with arrow
    xp set @a 0 levels

    as @e[type=armor_stand, tag=coop.spawn_location]:
        this.Marker = True
        this.Invulnerable = True
        this.Invisible = True
        this.CustomNameVisible = False

function coop:spawn_enemy:
    # vars[".enemy_to_spawn"] has to be set before running this
    e = vars[".enemy_to_spawn"]
    
    if e == Enemy.BASIC_ZOMBIE.value:
        function ./summon/basic_zombie
    elif e == Enemy.CONEHEAD_ZOMBIE.value:
        function ./summon/conehead_zombie
    elif e == Enemy.BUCKETHEAD_ZOMBIE.value:
        function ./summon/buckethead_zombie
    elif e == Enemy.SHIELD_ZOMBIE.value:
        function ./summon/shield_zombie
    elif e == Enemy.IMP.value:
        function ./summon/imp   
    elif e == Enemy.COLOR_IMP_TRIO.value:
        function ./summon/color_imp_trio

    as @n[tag=coop.spawn_temp]:
        enemy_aggro_timer["@s"] = 20
        tag @s remove coop.spawn_temp 

function coop:give/spawn_location_marker:
    give @s creeper_spawn_egg[item_model="minecraft:spawner",custom_name={"color":"red","italic":false,"text":"Spawn Location"},entity_data={id:"minecraft:armor_stand",CustomNameVisible:1b,NoGravity:1b,Invulnerable:1b,Small:1b,Tags:["coop.spawn_location"],DisabledSlots:4144959,Rotation:[0F,0F],CustomName:{"color":"red","italic":false,"text":"Spawn Location"}}] 1

function coop:stop_game:
    vars[".game_state"] = GameState.NOT_RUNNING.value
    say Game stopped!

function LOAD:
    tellraw @a {"text": "Loaded!", "color": "green"}
    setblock 0 0 0 yellow_shulker_box
    forceload add 0 0
    team add players "players"
    team add coin_color "coin color"
    team modify players friendlyFire false
    team modify coin_color color yellow

function TICK:
    as @a at @s function PLAYER_TICK

    # ðŸš« Disables XP dropping from enemies
    kill @e[type=experience_orb]

    # ðŸš« Disables item dropping
    as @e[type=item]:
        item_custom_data = this.Item.components."minecraft:custom_data"

        if not item_custom_data.allow_dropping:
           kill @s

    # Coin glowing behavior
    as @e[type=item, tag=!coop.coin_glow_applied]:
        team join coin_color @s
        this.Glowing = True
        tag @s add coop.coin_glow_applied
    
    as @e[tag=coop.enemy]:
        if enemy_aggro_timer["@s"] > 10:
            enemy_aggro_timer["@s"] = -1
            this.Silent = True
            damage @s 0 coop:poison by @p
            this.Silent = False
        elif enemy_aggro_timer["@s"] > 0:
            enemy_aggro_timer["@s"] += 1

    as @e[type=armor_stand, tag=coop.spawn_location]:
        if vars[".game_state"] == GameState.NOT_RUNNING.value:
            this.Marker = False
            this.Invulnerable = False
            this.Invisible = False
            this.CustomNameVisible = True

    as @e[type=arrow] at @s:
        if entity @s[tag=coop.weapon.blasthra.arrow] function coop:weapon/blasthra/tick_arrow
        if entity @s[tag=coop.weapon.plague_volley.arrow] function coop:weapon/plague_volley/tick_arrow
        if entity @e[tag=coop.weapon.iron_tempest.arrow] function coop:weapon/iron_tempest/tick_arrow

        if entity @s[tag=!coop.handles_own_despawn, tag=!coop.will_despawn]:
            if this.inGround:
                this.life = 1150
                tag @s add coop.will_despawn

    as @e[tag=coop.weapon.plague_volley.poisoned_entity] at @s function coop:weapon/plague_volley/tick_poisoned_entity

    # Game state handling
    if vars[".game_state"] == GameState.RUNNING.value:
        if len(storage.current_wave) == 0:
            # All waves spawned? -> return
            vars[".game_state"] = GameState.NOT_RUNNING.value
        elif len(storage.current_wave[0]) > 0:
            if vars[".enemy_spawn_timer"] <= 0:
                vars[".enemy_spawn_interval"] = randint_range(5, 40)
                vars[".enemy_spawn_timer"] = vars[".enemy_spawn_interval"]

                # Any enemies in current batch? -> Spawn next enemy in the batch & pop it
                # tellraw @a {"nbt":"current_wave[0][0]","storage":"coop:data"}
                at @e[tag=coop.spawn_location, sort=random, limit=1]:
                    vars[".enemy_to_spawn"] = storage.current_wave[0][0]
                    function coop:spawn_enemy

                storage.current_wave[0][0].remove()
            else:
                vars[".enemy_spawn_timer"] -= 1
        else:
            unless entity @e[tag=coop.enemy]:
                # All enemies spawned & killed? -> Pop empty list for current batch
                storage.current_wave[0].remove()
                say wave cleared!
                # Adjusting this will delay the first enemy of the next batch
                vars[".enemy_spawn_timer"] = 30 * 20

function PLAYER_TICK:
    team join players @s
    tick_reload_watcher()

    # ðŸš« Disables offhand
    if items entity @s weapon.offhand *:
        data remove block 0 0 0 Items
        item replace block 0 0 0 container.0 from entity @s weapon.offhand
        item replace entity @s weapon.offhand with air
        loot give @s mine 0 0 0 stick[custom_data={drop_contents:1b}]

    # ðŸª™ Convert collected coins into XP levels
    storage.args.remove()
    store result storage STORAGE args.arg_0 int 1:
        clear @s gold_nugget[minecraft:custom_data~{coin:1b}]

    if storage.args.arg_0 >= 1:
        with var storage.args:
            $xp add @s $(arg_0) levels
        stopsound @s * minecraft:entity.player.levelup
        playsound minecraft:entity.experience_orb.pickup master @s ~ ~ ~ 0.3 1.5

    sword_item_filter = '*[minecraft:custom_data~{weapon: "sword"}]'
    bow_item_filter = '*[minecraft:custom_data~{weapon: "bow"}]'

    # Upgrade book try buy triggers
    tmp[".coins"] = get_xp_levels()
    for entry_data in UPGRADE_BOOK_BOW_CONTENTS:
        if (upgrade_book_buy_trigger["@s"] == encode_trigger_value(entry_data.spec.value, entry_data.lvl)
            and tmp[".coins"] >= entry_data.price
        ):
            current_bow_spec["@s"] = entry_data.spec.value
            current_bow_level["@s"] = entry_data.lvl
            clear @s bow_item_filter

            price_inverted = entry_data.price * -1
            xp add @s price_inverted levels

            execute function coop:upgrade_book_trigger_cleanup:
                upgrade_book_buy_trigger["@s"].reset()
                clear @s written_book[minecraft:custom_data~{upgrade_book: 1b}]
                update_upgrade_menu_item(modify_existing_mainhand=True)

    for entry_data in UPGRADE_BOOK_SWORD_CONTENTS:
        if (upgrade_book_buy_trigger["@s"] == encode_trigger_value(entry_data.spec.value, entry_data.lvl)
            and tmp[".coins"] >= entry_data.price
        ):
            current_sword_spec["@s"] = entry_data.spec.value
            current_sword_level["@s"] = entry_data.lvl
            clear @s sword_item_filter

            price_inverted = entry_data.price * -1
            xp add @s price_inverted levels

            execute function coop:upgrade_book_trigger_cleanup:
                upgrade_book_buy_trigger["@s"].reset()
                clear @s written_book[minecraft:custom_data~{upgrade_book: 1b}]
                update_upgrade_menu_item(modify_existing_mainhand=True)


    upgrade_book_buy_trigger["@s"].reset()
    upgrade_book_buy_trigger["@s"].enable()

    # Item give logic
    if inventory_item_count(sword_item_filter) == 0:
        for itemstack in SWORD_ITEMSTACK_DEFINITIONS:
            if (
                current_sword_level["@s"] == itemstack.lvl
                and current_sword_spec["@s"] == itemstack.spec.value
            ):
                give @s itemstack.item_

    if inventory_item_count(bow_item_filter) == 0:
        for itemstack in BOW_ITEMSTACK_DEFINITIONS:
            if (
                current_bow_level["@s"] == itemstack.lvl
                and current_bow_spec["@s"] == itemstack.spec.value
            ):
                give @s itemstack.item_


        # SWORD_ITEMSTACK_DEFINITIONS

    # ðŸ“™ Ensuring upgrade book exists in inventory
    upgrade_book_count = inventory_item_count("written_book[minecraft:custom_data~{upgrade_book: 1b}]")
    if upgrade_book_count != 1:
        update_upgrade_menu_item(modify_existing_mainhand=False)
