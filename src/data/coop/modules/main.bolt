from bolt_expressions import Scoreboard, Data
from copy import copy
from src.definitions import
    LOAD,
    TICK,
    PLAYER_TICK,
    GameState,
    VAR_OBJECTIVE,
    TMP_OBJECTIVE,
    STORAGE,
    BASE_ENEMY_NBT,
    ItemSpec,

from ./reload import tick_reload_watcher
from ./loot_tables import generate_loot_tables
from ./helpers import predictable_arrow_rotation, inventory_item_count
from ./spec_itemstacks import BOW_ITEMSTACK_DEFINITIONS
from ./upgrade_book_contents import UPGRADE_BOOK_BOW_CONTENTS, EntryData
import ./weapon/blasthra as weapon_blasthra
import ./weapon/plague_volley as weapon_plague_volley
import ./weapon/iron_tempest as weapon_iron_tempest
import math

this = Data.entity("@s")
storage = Data.storage(STORAGE)
vars = Scoreboard(VAR_OBJECTIVE, "dummy")
tmp = Scoreboard(TMP_OBJECTIVE, "dummy")

upgrade_book_buy_trigger = Scoreboard("coop.upgrade_book.buy_trigger", "trigger")
current_bow_spec = Scoreboard("coop.current_spec.bow", "dummy")
current_bow_level = Scoreboard("coop.current_level.bow", "dummy")


merge function_tag minecraft:load {"values": [LOAD]}
merge function_tag minecraft:tick {"values": [TICK]}

generate_loot_tables()
weapon_blasthra.generate_funcs()
weapon_plague_volley.generate_funcs()
weapon_iron_tempest.generate_funcs()

def encode_trigger_value(spec: int, level: int) -> int:
    return spec * 1000 + level

def update_upgrade_menu_item(modify_existing_mainhand: bool):
    execute function coop:update_upgrade_menu_item:
        ysb_items = Data.block("0 0 0").Items
        main_item_data_text_list = ysb_items[0].components["minecraft:written_book_content"].pages[0].raw.extra
        aux_item_data_text = ysb_items[1].components["minecraft:written_book_content"].pages[0].raw
        
        br = "\n"
        blank_slate_modifier = '{function:"minecraft:set_written_book_pages",pages:[{raw:{text:"",extra:[""]}}],mode:"replace_all"}'

        # Initialization    
        ysb_items.remove()
        item replace block 0 0 0 container.0 with written_book[custom_data={upgrade_book: True}]
        item modify block 0 0 0 container.0 blank_slate_modifier
        item replace block 0 0 0 container.1 with written_book

        # This for loop is completely cursed
        # it's optimized for compile time by keeping commands inline
        # instead of spamming nested executes
        for entry_data in UPGRADE_BOOK_BOW_CONTENTS:
            item replace block 0 0 0 container.1 with written_book
            execute if score @s current_bow_level matches entry_data.req_lvl if score @s current_bow_spec matches entry_data.req_spec.value:
                encoded_upgrade_value = encode_trigger_value(entry_data.spec.value, entry_data.lvl)
                
                entry = {
                    "text": str(entry_data.lvl),
                    "color": "dark_green",
                    "extra": [
                        " ",
                        {
                            "text": entry_data.name,
                            "color": "black",
                        },
                        br
                    ],
                    "click_event": {
                        "action": "run_command",
                        "command": f"trigger {upgrade_book_buy_trigger} set {encoded_upgrade_value}",
                    }
                }

                modifier = {
                    "function": "minecraft:set_written_book_pages",
                    "pages": [entry],
                    "mode": "replace_all"
                }
                item modify block 0 0 0 container.1 modifier

            main_item_data_text_list.append(aux_item_data_text)

        # get rid of auxillary item before moving
        # stuff to the player's inventory
        ysb_items[1].remove()

    if modify_existing_mainhand:
        loot replace entity @s weapon.mainhand mine 0 0 0 stick[custom_data={drop_contents:1b}]
    else:
        clear @s written_book[minecraft:custom_data~{upgrade_book: 1b}]
        loot give @s mine 0 0 0 stick[custom_data={drop_contents:1b}]

function coop:summon/basic_zombie:
    nbt = copy(BASE_ENEMY_NBT)
    nbt["Tags"].append("basic_zombie")
    nbt["DeathLootTable"] = "coop:coin_10"
    summon zombie ~ ~ ~ nbt

function coop:start_game:
    vars[".game_state"] = GameState.RUNNING.value
    say Game started!

    current_bow_spec["@a"] = ItemSpec.NONE.value
    current_bow_level["@a"] = 0
    # clear @s written_book[minecraft:custom_data~{upgrade_book: 1b}]
    clear @a

function coop:stop_game:
    vars[".game_state"] = GameState.NOT_RUNNING.value
    say Game stopped!

function LOAD:
    tellraw @a {"text": "Loaded!", "color": "green"}
    setblock 0 0 0 yellow_shulker_box
    forceload add 0 0

function TICK:
    as @a at @s function PLAYER_TICK

    # ðŸš« Disables XP dropping from enemies
    kill @e[type=experience_orb]

    # ðŸš« Disables item dropping
    as @e[type=item]:
        item_custom_data = this.Item.components."minecraft:custom_data"

        if not item_custom_data.allow_dropping:
           kill @s

    as @e[type=arrow] at @s:
        if entity @s[tag=coop.weapon.blasthra.arrow] function coop:weapon/blasthra/tick_arrow
        if entity @s[tag=coop.weapon.plague_volley.arrow] function coop:weapon/plague_volley/tick_arrow
        if entity @e[tag=coop.weapon.iron_tempest.arrow] function coop:weapon/iron_tempest/tick_arrow

        if entity @s[tag=!coop.handles_own_despawn, tag=!coop.will_despawn]:
            if this.inGround:
                this.life = 1150
                tag @s add coop.will_despawn
            # if data entity @s {inGround: True} data modify entity @s life set value 199

    as @e[tag=coop.weapon.plague_volley.poisoned_entity] at @s function coop:weapon/plague_volley/tick_poisoned_entity

    if vars[".game_state"] == GameState.RUNNING.value:
        pass

function PLAYER_TICK:
    tick_reload_watcher()

    # ðŸš« Disables offhand
    if items entity @s weapon.offhand *:
        data remove block 0 0 0 Items
        item replace block 0 0 0 container.0 from entity @s weapon.offhand
        item replace entity @s weapon.offhand with air
        loot give @s mine 0 0 0 stick[custom_data={drop_contents:1b}]

    # ðŸª™ Convert collected coins into XP levels
    storage.args.remove()
    store result storage STORAGE args.arg_0 int 1:
        clear @s gold_nugget[minecraft:custom_data~{coin:1b}]

    if storage.args.arg_0 >= 1:
        with var storage.args:
            $xp add @s $(arg_0) levels
        stopsound @s * minecraft:entity.player.levelup
        playsound minecraft:entity.experience_orb.pickup master @s ~ ~ ~ 0.3 1.5

    # ðŸ“™ Ensuring upgrade book exists in inventory
    upgrade_book_count = inventory_item_count("written_book[minecraft:custom_data~{upgrade_book: 1b}]")
    if upgrade_book_count != 1:
        update_upgrade_menu_item(modify_existing_mainhand=False)

    bow_item_filter = '*[minecraft:custom_data~{weapon: "bow"}]'

    # Upgrade book item use triggers
    for entry_data in UPGRADE_BOOK_BOW_CONTENTS:
        if upgrade_book_buy_trigger["@s"] == encode_trigger_value(entry_data.spec.value, entry_data.lvl):
            current_bow_spec["@s"] = entry_data.spec.value
            current_bow_level["@s"] = entry_data.lvl
            clear @s bow_item_filter

            execute function coop:upgrade_book_trigger_cleanup:
                upgrade_book_buy_trigger["@s"].reset()
                clear @s written_book[minecraft:custom_data~{upgrade_book: 1b}]
                update_upgrade_menu_item(modify_existing_mainhand=True)

    upgrade_book_buy_trigger["@s"].enable()

    # Item give logic
    if inventory_item_count(bow_item_filter) == 0:
        for itemstack in BOW_ITEMSTACK_DEFINITIONS:
            if (
                current_bow_level["@s"] == itemstack.lvl
                and current_bow_spec["@s"] == itemstack.spec.value
            ):
                give @s itemstack.item_
